//! Integration tests for Cargo.lock conflict resolution
//!
//! Tests the interaction between:
//! - issue/01-pyo3-version-upgrade: PyO3 v0.25 upgrade
//! - issue/07-file-cleanup-and-cargo-lock-removal: Cargo.lock removal from git
//!
//! Priority: HIGH - This is a conflict resolution area
//!
//! Key risks:
//! - Build succeeds with PyO3 v0.25 dependencies
//! - Cargo.lock is untracked from git but exists on disk
//! - PyO3 is only a dev-dependency (not in release binary)
//! - No version conflicts or dependency issues

use std::process::Command;

#[test]
fn test_cargo_lock_exists_on_disk() {
    // Cargo.lock should exist on disk (generated by cargo)
    let cargo_lock_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.lock");

    assert!(
        std::path::Path::new(cargo_lock_path).exists(),
        "Cargo.lock should exist on disk for dependency resolution"
    );
}

#[test]
fn test_cargo_lock_not_in_git() {
    // Cargo.lock should be untracked from git (issue/07)
    let output = Command::new("git")
        .args(&["ls-files", "Cargo.lock"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run git ls-files");

    let tracked_files = String::from_utf8_lossy(&output.stdout);

    assert!(
        tracked_files.trim().is_empty(),
        "Cargo.lock should not be tracked in git"
    );
}

#[test]
fn test_pyo3_version_in_cargo_toml() {
    // Verify PyO3 version is 0.25 in Cargo.toml
    let cargo_toml_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");

    let cargo_toml = std::fs::read_to_string(cargo_toml_path).expect("Failed to read Cargo.toml");

    // Check for pyo3 = { version = "0.25" in dev-dependencies
    assert!(
        cargo_toml.contains("pyo3") && cargo_toml.contains("0.25"),
        "PyO3 version should be 0.25 in Cargo.toml"
    );
}

#[test]
fn test_pyo3_is_dev_dependency_only() {
    // Verify pyo3 is only in [dev-dependencies]
    let cargo_toml_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");

    let cargo_toml = std::fs::read_to_string(cargo_toml_path).expect("Failed to read Cargo.toml");

    // Split into sections
    let sections: Vec<&str> = cargo_toml.split("[dependencies]").collect();

    if sections.len() > 1 {
        let deps_section = sections[1].split("[dev-dependencies]").next().unwrap();
        assert!(
            !deps_section.contains("pyo3"),
            "pyo3 should not be in [dependencies], only in [dev-dependencies]"
        );
    }

    // Verify it IS in dev-dependencies
    assert!(
        cargo_toml.contains("[dev-dependencies]"),
        "Should have dev-dependencies section"
    );

    let dev_deps_section = cargo_toml.split("[dev-dependencies]").nth(1).unwrap_or("");
    assert!(
        dev_deps_section.contains("pyo3"),
        "pyo3 should be in [dev-dependencies]"
    );
}

#[test]
fn test_cargo_metadata_shows_pyo3_version() {
    // Use cargo metadata to verify pyo3 version
    let output = Command::new("cargo")
        .args(&["metadata", "--format-version=1", "--no-deps"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run cargo metadata");

    assert!(output.status.success(), "cargo metadata should succeed");

    let metadata = String::from_utf8_lossy(&output.stdout);

    // Verify pyo3 is listed in dependencies
    assert!(
        metadata.contains("pyo3") && metadata.contains("0.25"),
        "cargo metadata should show pyo3 version 0.25"
    );
}

#[test]
fn test_library_compiles_with_pyo3_v022() {
    // Verify library compiles successfully with PyO3 v0.25
    let output = Command::new("cargo")
        .args(&["build", "--lib"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run cargo build");

    assert!(
        output.status.success(),
        "cargo build --lib should succeed with PyO3 v0.25"
    );
}

#[test]
fn test_tests_compile_with_pyo3_v022() {
    // Verify tests compile with PyO3 v0.25
    let output = Command::new("cargo")
        .args(&["test", "--no-run", "--lib"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run cargo test --no-run");

    assert!(
        output.status.success(),
        "cargo test --no-run should succeed with PyO3 v0.25"
    );
}

#[test]
fn test_gitignore_includes_cargo_lock() {
    // Verify .gitignore includes Cargo.lock pattern
    let gitignore_path = concat!(env!("CARGO_MANIFEST_DIR"), "/.gitignore");

    if let Ok(gitignore) = std::fs::read_to_string(gitignore_path) {
        // Cargo.lock might be explicitly listed or covered by pattern
        // Either is acceptable
        let has_cargo_lock = gitignore.contains("Cargo.lock") || gitignore.contains("*.lock");

        // This is informational - not a hard requirement
        if !has_cargo_lock {
            println!("Note: Cargo.lock not explicitly in .gitignore");
        }
    }
}

#[test]
fn test_no_pyo3_in_release_binary_dependencies() {
    // Verify that release binary doesn't link against pyo3
    // This is checked by ensuring pyo3 is dev-only
    let cargo_toml_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");

    let cargo_toml = std::fs::read_to_string(cargo_toml_path).expect("Failed to read Cargo.toml");

    // Verify pyo3 has no default features that would link it in release
    if let Some(dev_deps_section) = cargo_toml.split("[dev-dependencies]").nth(1) {
        if let Some(pyo3_line) = dev_deps_section.lines().find(|l| l.contains("pyo3")) {
            // Should have auto-initialize feature for tests
            assert!(
                pyo3_line.contains("auto-initialize") || pyo3_line.contains("features"),
                "pyo3 should have auto-initialize feature for tests"
            );
        }
    }
}

#[test]
fn test_cargo_lock_regenerates_correctly() {
    // Test that Cargo.lock can be regenerated by cargo
    let output = Command::new("cargo")
        .args(&["generate-lockfile"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run cargo generate-lockfile");

    assert!(
        output.status.success(),
        "Should be able to regenerate Cargo.lock"
    );

    // Verify it exists after regeneration
    let cargo_lock_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.lock");

    assert!(
        std::path::Path::new(cargo_lock_path).exists(),
        "Cargo.lock should exist after regeneration"
    );
}

#[test]
fn test_dependencies_resolve_without_conflicts() {
    // Run cargo check to verify all dependencies resolve
    let output = Command::new("cargo")
        .args(&["check", "--lib"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run cargo check");

    let stderr = String::from_utf8_lossy(&output.stderr);

    assert!(
        output.status.success(),
        "cargo check should succeed without dependency conflicts"
    );

    // Verify no warnings about version conflicts
    assert!(
        !stderr.contains("version conflict"),
        "Should not have version conflicts"
    );
}

#[test]
fn test_pyo3_features_are_correct() {
    // Verify pyo3 features match requirements
    let cargo_toml_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");

    let cargo_toml = std::fs::read_to_string(cargo_toml_path).expect("Failed to read Cargo.toml");

    // pyo3 should have auto-initialize feature in dev-dependencies
    let dev_deps_section = cargo_toml.split("[dev-dependencies]").nth(1).unwrap_or("");

    // Find the pyo3 line
    let pyo3_line = dev_deps_section
        .lines()
        .find(|line| line.trim().starts_with("pyo3"));

    assert!(pyo3_line.is_some(), "pyo3 should be in dev-dependencies");
    assert!(
        pyo3_line.unwrap().contains("auto-initialize"),
        "pyo3 should have auto-initialize feature"
    );
}

#[test]
fn test_no_warnings_about_pyo3_version() {
    // Verify cargo doesn't warn about pyo3 version
    let output = Command::new("cargo")
        .args(&["build", "--lib", "--quiet"])
        .current_dir(env!("CARGO_MANIFEST_DIR"))
        .output()
        .expect("Failed to run cargo build");

    let stderr = String::from_utf8_lossy(&output.stderr);

    assert!(
        !stderr.contains("pyo3") || !stderr.contains("warning"),
        "Should not have warnings about pyo3"
    );
}
